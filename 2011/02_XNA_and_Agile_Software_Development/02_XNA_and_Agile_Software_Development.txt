<span style="font-family:verdana;font-size:85%;"><a href="http://en.wikipedia.org/wiki/Agile_software_development">Agile development</a> is a modern approach to software engineering that provides an iterative incremental framework for managing complex work.  Efficiency is key: by minimizing rework and debugging, teams can more rapidly respond to changing business requirements and improve quality at the same time.<br /><br />Game development, by nature, is complex and has many specialized disciplines:<br /><table width="100%"><tr><td valign="top">
<ul><li>Core Systems: <i>engine configuration, math library, localization</i></li><li>Resources (Game Assets): <i>audio, fonts, models, textures</i></li><li>Human Input Devices (HID): <i>input detection</i></li>
<li>Collision & Physics: <i>rigid bodies</i></li><li>Online Multiplayer: <i>networking</i></li><li>Front End: <i>heads-up display, in-game menus, visual effects</i></li><li>Game Play Foundations: <i>event messaging, finite state machine</i></li><li>Game Specific Subsystems: <i>rendering, player mechanics, cameras, AI</i></li></ul></td></tr></table>Therefore, each game may have many components working together and subsystems interacting with one another, many of which may depend on other components and subsystems too.<br /><br />Consequently, the task of coding and testing game components in isolation can be very challenging due to the tightly coupled nature of these dependencies.<br /><br /><u>Example</u>
<br /><a href="http://en.wikipedia.org/wiki/Asteroids_(video_game)">Asteroids</a>: in this simple game, the player controls a spaceship depending on input from the controller.<br />In order to test the spaceship's rotate and move methods in isolation, the external dependency on the controller must be broken.<br /><br /><u>Dependency Injection and Inversion of Control (IoC)</u><br />When an object instantiates another object that it depends on then this leads to poor design because it promotes tight coupling between the objects.  Tightly coupled code cannot be changed easily without consequences: changes made to one object may cause other objects to break.
<br /><br />A better approach is to break dependencies between objects and promote loose coupling:<br /><a href="http://www.xyzws.com/scjp/SGS11/5/2">Loose coupling</a> leads to better design as the software is less likely to break.<br /><br /><a href="http://en.wikipedia.org/wiki/Dependency_injection">Dependency Injection</a> is a simple pattern to loosely couple objects and break their dependencies.<br />The resulting design principle, <a href=" http://en.wikipedia.org/wiki/Dependency_inversion_principle">Dependency Inversion</a>, states: <i>Depend upon abstractions.<br />Do not depend upon concrete classes.</i><br /><br />By coupling an object to an interface instead of a specific concrete implementation, you have the ability to use any implementation with minimal change and risk.  This concept is important, especially when testing an object in isolation (unit testing).<br /><br /><a href="http://en.wikipedia.org/wiki/Inversion_of_control">Inversion of Control</a> (IoC) is a framework characteristic whereby objects, which depend on other objects, do not need to instantiate those objects; instead they get the objects they need from an external source.<br /><br /><u>IoC Container</u><br />An <a href="http://www.martinfowler.com/articles/injection.html">IoC Container</a> is a framework component that automatically resolves all dependent references for an object: when an object is constructed, the container will instantiate all dependent objects automatically and injects them into the source object accordingly.<br /><br />There are many IoC containers available to .NET developers:
<br /><table width="100%"><tr><td valign="top"><ul><li><a href="http://code.google.com/p/autofac">Autofac</a></li><li><a href="http://www.castleproject.org/container/index.html">Castle Windsor</a></li><li><a href="http://ninject.org">Ninject</a></li><li><a href="http://www.springframework.net">Spring.NET</a></li><li><a href="http://structuremap.net/structuremap/index.html">StructureMap</a></li><li><a href="http://unity.codeplex.com">Unity</a></li></ul></td></tr></table>However, <a href="http://ninject.org">Ninject</a> is currently the only IoC container that is compatible with the <a href="http://en.wikipedia.org/wiki/.NET_Compact_Framework">.NET Compact Framework</a> and will work on <a href="http://www.microsoft.com/windowsphone/en-us/default.aspx">Windows Phone 7</a> and <a href="http://www.xbox.com">Xbox 360</a>.<br /><br /><u>Unit Testing</u><br /><a href="http://en.wikipedia.org/wiki/Unit_testing">Unit testing</a> is the practice in which individual units of source code are tested in isolation.  Consequently, unit tests do not measure how objects interact with dependent objects; these are integration <a href="http://en.wikipedia.org/wiki/Integration_testing">tests</a>.<br /><br />In order to successfully unit test an individual game component, external dependencies are broken, and replaced by <a href="http://en.wikipedia.org/wiki/Mock_object">mock objects</a>: fake objects that emulate real classes and help test expectations about how that class should function.<br /><br />Therefore, clean unit tests should be written <a href="http://java.dzone.com/articles/why-you-should-read-clean-code">F.I.R.S.T</a>:<br /><table width="100%"><tr><td valign="top">Fast<br />Independent<br />Repeatable<br />Self-validating<br />Timely<br /></td><td valign="top">Tests should be fast<br />Tests should not depend on each other<br />Tests should be repeatable in any environment<br />Tests should have a Boolean output: either they pass or fail<br />
Tests should be written in a timely fashion<br /></td></tr></table><br /><u>Test Driven Development (TDD)</u><br /><a href="http://en.wikipedia.org/wiki/Test-driven_development">Test driven development</a> (TDD) is similar to unit testing except the unit tests are written <i>before</i> the objects they test.  TDD is gaining as a development best practice because objects are designed with testability in mind: an object and its dependencies must be loosely coupled from the outset.<br /><br />TDD practitioners follow these three <a href="http://www2.imm.dtu.dk/pubdb/views/edoc_download.php/5571/pdf/imm5571.pdf">laws</a>:<br /><table width="100%"><tr><td valign="top">First Law:<br />Second Law:<br />Third Law:<br /></td><td valign="top">You may not write production code unless you&#8217;ve first written a failing unit test<br />You may not write more of a unit test than is sufficient to fail<br />You may not write more production code than is sufficient to make the failing unit test pass<br /></td></tr></table><br /><u>Extreme Programming</u><br /><a href="http://en.wikipedia.org/wiki/Extreme_Programming">Extreme Programming</a> is a method of agile software development which advocates frequent <i>releases</i> with short development cycles.  The focus on delivering business value within each iteration leads to increased quality and lower overall total cost.<br /><br />Therefore, it seems only relevant to try and integrate agile methodologies into <a href="http://en.wikipedia.org/wiki/XNA_(Microsoft)">XNA</a> game development.  As an exercise, I would like to prototype the following agile techniques accordingly:<br />
<table width="100%"><tr><td valign="top"><ul><li><a href="http://steveproxna.blogspot.com/2011/02/xna-and-dependency-injection.html">XNA and Dependency Injection</a></li><li><a href="http://steveproxna.blogspot.com/2011/03/xna-and-ioc-container.html">XNA and an IoC Container</a></li><li><a href="http://steveproxna.blogspot.com/2011/03/xna-and-unit-testing.html">XNA and Unit Testing</a></li><li><a href="http://steveproxna.blogspot.com/2011/04/xna-and-test-driven-development.html">XNA and Test Driven Development</a></li></ul></td></tr></table>In conclusion, it will be interesting to see if agile development has the potential to scale using XNA!</span>